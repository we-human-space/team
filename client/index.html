<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale = 1.0 maximum-scale=1.0 user-scalable=no" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <title>Futureboy World</title>

    <link rel="apple-touch-icon" sizes="57x57" href="assets/img/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="assets/img/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="assets/img/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="assets/img/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="assets/img/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="assets/img/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="assets/img/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="assets/img/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="assets/img/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="assets/img/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="assets/img/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="assets/img/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="assets/img/favicon/favicon-16x16.png">
    <link rel="manifest" href="assets/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="assets/img/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/87/three.js"></script>
    <script type="text/javascript" src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.5/dat.gui.min.js"></script>
    <script type="text/javascript" src="https://code.createjs.com/tweenjs-0.6.2.min.js"></script>

    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
  <div id="stats-container"></div>
  <div id="three-container"></div>
</div>

<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    function init() {

        var stats = initStats();

        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        var webGLRenderer = new THREE.WebGLRenderer();
        webGLRenderer.setClearColor(0, 1.0);
        webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        webGLRenderer.shadowMapEnabled = true;

        // position and point the camera to the center of the scene
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 100;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        // add the output of the renderer to the html element
        document.getElementById("three-container").appendChild(webGLRenderer.domElement);

        var orbit = new THREE.OrbitControls( camera, webGLRenderer.domElement );
        orbit.enableZoom = true;

        // draw an axis helper
        var axesLength = 20;
        var axes = new THREE.AxisHelper(axesLength);
        // var axesLabels = {
        //   x: new Text2D('x', {size: 10, height: 4, color: { r:1, g:0, b:0 }}),
        //   y: new Text2D('y', {size: 10, height: 4, color: { r:0, g:1, b:0 }}),
        //   z: new Text2D('z', {size: 10, height: 4, color: { r:0, g:0, b:1 }})
        // };
        // axesLabels.x.text.position.x = axesLength+1;
        // axesLabels.y.text.position.y = axesLength+1;
        // axesLabels.z.text.position.z = axesLength+1;

        scene.add(axes);
        // scene.add(axesLabels.x.text);
        // scene.add(axesLabels.y.text);
        // scene.add(axesLabels.z.text);

        // draw the helix
        var helix = new Helix({scene: scene});

        // plane = new THREE.Object3D();
        // plane.add( new THREE.LineSegments(
  			// 	new THREE.PlaneGeometry(60, 60, 16, 16),
        //   new THREE.ShaderMaterial( {
        //     vertexShader: document.getElementById( 'vshader' ).textContent,
        //     fragmentShader: document.getElementById( 'fshader' ).textContent,
        //     uniforms: {
        //       offset: { type: "f", value: 0 },
        //       gridSize: { type: "f", value: 16 }
        //     },
        //     transparent: false,
        //     wireframe: true,
        //     wireframeLinewidth: 20,
        //     side: THREE.FrontSide,
        //     blending: THREE.AdditiveBlending,
  			// 	})
  			// ));
        //
        // plane.add( new THREE.LineSegments(
  			// 	new THREE.PlaneGeometry(60, 60, 1, 1),
        //   new THREE.LineBasicMaterial( {
  			// 		color: 0xffffff,
  			// 		transparent: true,
  			// 		opacity: 0.1
  			// 	})
  			// ) );
        // // var plane = new THREE.Mesh(planeGeometry, planeMaterial);
        // plane.receiveShadow = true;
        // plane.position.y = helix.spread * (helix.position.y + helix.position.offset);
        // plane.rotation.x = -Math.PI/2;
        // plane.rotation.y = 0;
        // plane.rotation.z = 0;
        // scene.add(plane);

        // setup the control gui
        var gui = new ControlsView(new Controls(helix));

        render();

        function render() {
            stats.update();
            helix.update();
            // render using requestAnimationFrame
            requestAnimationFrame(render);
            webGLRenderer.render(scene, camera);
        }

        function initStats() {

            var stats = new Stats();
            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.getElementById("stats-container").appendChild(stats.domElement);

            return stats;
        }

    }

    /**
     * Constants
     * Will be refactored in their own modules where applicable
     **/
    const ANIMATIONS = {
      DEFAULT: 'DEFAULT',
      PARTICLES: 'PARTICLES'
    }

    const START_POSITIONS = {
      TOP: 'TOP',
      BOTTOM: 'BOTTOM'
    };


    /**
     * Helix
     **/
    class Helix {

      constructor(options){
        this.numberOfPoints = typeof options.numberOfPoints === 'number' ? options.numberOfPoints : 150;
        this.radius = typeof options.radius === 'number' ? options.radius : 4;
        this.spread = typeof options.spread === 'number' ? options.spread : 0.3;
        this.density = typeof options.density === 'number' ? options.density : 60;
        this.phase = typeof options.phase !== 'number' ? Math.PI : options.phase;
        this.scene = options.scene;
        this.position =
          typeof options.position === 'object' ?
          {
            x: typeof options.position.x === 'number' ? options.position.x : 0,
            y: typeof options.position.y === 'number' ? options.position.y : 0,
            z: typeof options.position.z === 'number' ? options.position.z : 0,
            offset: typeof options.position.offset === 'number' ? options.position.offset : 75
          } :
          {
            x: 0,
            y: 0,
            z: 0,
            offset: -75
          };
        // Named this property revolution instead of rotation because making reference
        // to process of rotation about oneself, rather than rotation with regards to
        // axes. Hence when rotation is used, it is the value f(t=ti) of the revolution
        this.revolution =
          typeof options.revolution === 'object' ?
          {
            x: typeof options.revolution.x === 'number' ? options.revolution.x : 0,
            y: typeof options.revolution.y === 'number' ? options.revolution.y : 0,
            z: typeof options.revolution.z === 'number' ? options.revolution.z : 0
          } :
          {
            x: 0,
            y: 0,
            z: 0
          };
        let animation = options.animation;
        this.animation = {
          active: true,
          delay: typeof animation === 'object' && typeof animation.delay === 'number' ?
                 animation.delay :
                 10,
          startPosition: animation === 'object' && Object.keys(START_POSITIONS).indexOf(animation.startPosition) !== -1 ?
                         animation.startPosition :
                         START_POSITIONS.BOTTOM
        };
        this.points = [];
        this.helix3D = null;
        this.animator = new HelixAnimator();
        this._generatePoints();
        if(options.animate){
          this.drawWithAnimation();
        }else{
          this.draw();
        }
      }

      get animate() { return this.animation.active; }

      set animate(animate) {
        this.animation.active = !!animate;
        if(!!animate) {
          this.animator.activate(this);
        }
      }

      _generatePoints(){
        console.log(this);
        for(let i = 0 ; i < this.numberOfPoints; i++) {
          this.points[i] = [];
          for (let t = 0; t < this.numberOfPoints; t++) {
              let x = this.radius * Math.cos((2*Math.PI/this.density)*t+i*this.phase)+ this.position.x;
              let z = this.radius * Math.sin((2*Math.PI/this.density)*t+i*this.phase)+ this.position.z;
              let y = this.spread*(t + this.position.y + this.position.offset);

                      // o = 2πf
                      // f = o/2π
                      // let o = 200π
                      // then f = 100.
                      // y = a(t+b) = at + ab => a is coefficient determining total length of structure
                      // b = position.y - numberOfPoints/2 => center structure at y=0
                      // assuming t has a range of [0,100]
                      // total length of spiral is 100*a
                      // thus total length of cycle = 100*a/f
                      // which in this case is a
                      // a is thus the spacing between the points, assuming that 1
                      // is the default where total length of spiral = range of t.
                      // let f be named frequency
                      // let a be named spread
                      // If I want t=100 squares per cycle, I should have
                      // f=2π/100


              this.points[i].push(new THREE.Vector3(x, y, z));
          }
        }
      }

      draw(){
        var scene = this.scene;
        var helix3D = new THREE.Object3D();

        scene.remove(this.helix3D);
        this.helix3D = helix3D;

        this.points[0].forEach(draw_point);
        this.points[1].forEach(draw_point);
        scene.add(helix3D);

        function draw_point(point) {
          var sprite = new THREE.Sprite(new THREE.SpriteMaterial({color: Math.random() * 0x00ffff}));
          sprite.position.copy(point);
          helix3D.add(sprite);
        }
      }



      drawWithAnimation(type){
        var helix = this;
        var scene = helix.scene;
        var helix3D = new THREE.Object3D();

        scene.remove(this.helix3D);
        this.helix3D = helix3D;
        scene.add(helix3D);

        helix.animator.animate(this, type);
      }


      redraw(animate){
        this.animate = animate;
        this.points = [];
        this._generatePoints();
        if(animate){
          this.drawWithAnimation();
        }else{
          this.draw();
        }
      }

      update(){
        this.helix3D.rotation.x += this.revolution.x;
        this.helix3D.rotation.y += this.revolution.y;
        this.helix3D.rotation.z += this.revolution.z;
      }
    }

    /**
     * Helix Animator Module
     * Currently scoped as a class for the time being - will be refactored in an ES6 module
    **/
    class HelixAnimator {
      constructor() {
        this.animations = [];
      }

      activate() {
        this.animations.forEach((a) => {
          if(a.cb) a.cb();
        });
      }

      animate(helix, type) {
        var animation = {
          type: type || ANIMATIONS.DEFAULT,
          delay: helix.delay,
          progress: {
            strand: 0,
            i: helix.animation.startPosition === START_POSITIONS.TOP ? helix.numberOfPoints-1: 0
          },
          cb: null
        };

        this.animations.push(animation);

        switch(animation.type){
          case ANIMATIONS.DEFAULT:
            this.default_animation(helix, animation, this.animations.length-1);
            break;
          case ANIMATIONS.PARTICLES:
            this.particles_animation(helix, animation, this.animations.length-1);
            break;
          default:
            this.default_animation(helix, animation, this.animations.length-1);
            break;
        }
      }

      default_animation(helix, animation, animation_index) {
        var animator = this;
        var helix3D = helix.helix3D;

        return draw_point(animation);

        function draw_point(animation) {
          if(animation.progress.i >= helix.numberOfPoints || animation.progress.i < 0){
            animator.animations.splice(animation_index, 1);
            return;
          }

          if(!helix.animate){
            animation.cb = () => {
              animation.cb = null;
              draw_point(animation);
            };
            return;
          }

          var sprite = new THREE.Sprite(new THREE.SpriteMaterial({color: Math.random() * 0x00ffff}));
          sprite.position.copy(helix.points[animation.progress.strand][animation.progress.i]);
          helix3D.add(sprite);
          animation.progress.strand = (animation.progress.strand+1)%2;
          if(helix.animation.startPosition === START_POSITIONS.TOP){
            animation.progress.i = animation.progress.strand ? animation.progress.i : animation.progress.i-1;
          }else{
            animation.progress.i = animation.progress.strand ? animation.progress.i : animation.progress.i+1;
          }
          setTimeout(() => draw_point(animation), animation.delay);
        }
      }

      particles_animation(helix, animation, animation_index) {

      }

    }

    class Controls {
      constructor(helix){
        this.helix = helix;
        this.model = {
          numberOfPoints: helix.numberOfPoints,
          radius: helix.radius,
          density: helix.density,
          spread: helix.spread,
          phase: helix.phase,
          animation: {
            animate: false,
            delay: helix.animation.delay,
            startPosition: helix.animation.startPosition
          },
          position: {
            x: helix.position.x,
            y: helix.position.y,
            z: helix.position.z,
            offset: helix.position.offset
          },
          revolution: {
            x: helix.revolution.x,
            y: helix.revolution.y,
            z: helix.revolution.z,
            stop: false,
            reset: () => this.updateRevolution(true),
            resetAll: () => this.updateRevolution(true, true)
          }
        }
      }

      redraw() {
        for(let k in this.model) this.helix[k]=this.model[k]
        this.helix.redraw(this.model.animation.animate);
      }

      updateRevolution(reset, all) {
        if(reset) {
          this.helix.helix3D.rotation.x = 0;
          this.helix.helix3D.rotation.y = 0;
          this.helix.helix3D.rotation.z = 0;
          if(all) {
            this.helix.revolution = {
              x: 0,
              y: 0,
              z: 0
            };
          }
        }else if(this.model.revolution.stop) {
          this.helix.revolution = {
            x: 0,
            y: 0,
            z: 0
          };
        }else{
          this.helix.revolution = {
            x: this.model.revolution.x,
            y: this.model.revolution.y,
            z: this.model.revolution.z
          }

        }
      }
    }

    class ControlsView {
      constructor(controls) {
        this.gui = new dat.GUI();
        let gui = this.gui;
        gui.helix = gui.addFolder('Helix');
        gui.helix.structure = gui.helix.addFolder('structure');
        gui.helix.structure.add(controls.model, 'numberOfPoints', 2, 250).step(1);
        gui.helix.structure.add(controls.model, 'radius', 0, 10);
        gui.helix.structure.add(controls.model, 'density', 0, 500);
        gui.helix.structure.add(controls.model, 'spread', 0, 10);
        gui.helix.structure.add(controls.model, 'phase', 0, 10);
        gui.helix.position = gui.helix.addFolder('position');
        gui.helix.position.add(controls.model.position, 'x', 0, 10);
        gui.helix.position.add(controls.model.position, 'y', 0, 10);
        gui.helix.position.add(controls.model.position, 'z', 0, 10);
        gui.helix.position.add(controls.model.position, 'offset', -300, 300);
        gui.helix.animation = gui.helix.addFolder('animation');
        gui.helix.animation.add(controls.model.animation, 'delay', 0, 100);
        gui.helix.animation.add(controls.model.animation, 'startPosition', ['TOP', 'BOTTOM']);
        gui.helix.animation.add(controls.model.animation, 'animate').onChange(() => controls.helix.animate = controls.model.animation.animate);
        gui.helix.revolution = gui.helix.addFolder('revolution');
        gui.helix.revolution.add(controls.model.revolution, 'x', -0.1, 0.1).onChange(() => controls.updateRevolution());
        gui.helix.revolution.add(controls.model.revolution, 'y', -0.1, 0.1).onChange(() => controls.updateRevolution());
        gui.helix.revolution.add(controls.model.revolution, 'z', -0.1, 0.1).onChange(() => controls.updateRevolution());
        gui.helix.revolution.add(controls.model.revolution, 'stop').onChange(() => controls.updateRevolution());
        gui.helix.revolution.add(controls.model.revolution, 'reset');
        gui.helix.revolution.add(controls.model.revolution, 'resetAll');
        gui.helix.add(controls, 'redraw');
      }

    }

    // class Text2D {
    //   constructor(message, options){
    //     this.message = message;
    //     this.size = typeof options.size === 'number' ? options.size : 5;
    //     this.height = typeof options.height === 'number' ? options.height : 2;
    //     this.curveSegments = typeof options.curveSegments === 'number' ? options.curveSegments : 6;
    //     this.font = typeof options.font == 'string' ? options.font : 'helvetiker';
    //     this.style = typeof options.style == 'string' ? options.style : 'normal';
    //     let r = options.color.r,
    //         g = options.color.g,
    //         b = options.color.b;
    //
    //     this.color = {
    //       r: typeof r === 'number' && r >= 0 && r < 257 ? r : 0,
    //       g: typeof g === 'number' && g >= 0 && g < 257 ? g : 0,
    //       b: typeof b === 'number' && b >= 0 && b < 257 ? b : 0
    //     }
    //
    //     this.geometry = new THREE.TextGeometry(message,
    //     {
    //        size: this.size,
    //        height: this.height,
    //        curveSegments: this.curveSegments,
    //        font: this.font,
    //        style: this.style
    //     });
    //
    //     this.color = new THREE.Color();
    //     this.color.setRGB(this.color.r, this.color.g, this.color.b);
    //     this.material = new THREE.MeshBasicMaterial({ color: color });
    //     this.text = new THREE.Mesh(this.geometry, this.material);
    //   }
    // }

    window.onload = init;
</script>
</body>
</html>
